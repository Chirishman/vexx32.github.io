---
layout: post
title: Error Handling in PowerShell - Best Practices
date: 2019-01-31
categories: [PowerShell, Scripting, "Best Practices"]
tags: [powershell, pwsh, errors]
---

Intro paragraph (this will be used as the synopsis/summary/excerpt on the post listing pages)

# Different Types of Errors

## Terminating Errors

**Terminating** errors are mostly an "exactly what it sounds like" package in general use.
Their common characteristics are as follows:

* Trigger `try`/`catch` blocks
* Return control to the caller, along with the exception, if they're not handled using a try/catch block.

There are a couple different ways to get a terminating error in PowerShell, and each has its own
small differences that make them more useful in a tricky situation.

### Throw

First is your typical `throw` statement, which simply takes an exception message as its only input.

```powershell
throw "Something went wrong"
```

`throw` creates an exception and an ErrorRecord (PowerShell's more detailed version of an exception)
in a single, simple statement, and wraps them together.
Its exceptions display the entered error message, a generic `RuntimeException`, and the errorID
matches the entered exception message.
`throw` exceptions are affected by `-ErrorAction` parameters of their advanced functions.

`throw` should generally be used for simple runtime errors, where you need to halt execution, but
typically only if you plan to `catch` it yourself later; there is no guarantee a user will not
elect to simply ignore your error with `-ErrorAction Ignore` and continue with their lives if it
is passed up from your functions.

### ThrowTerminatingError()

Next, we have a more advanced version of the throw statement. `ThrowTerminatingError()` is a method
that comes directly from PowerShell's `PSCmdlet` .NET class, and is accessible only in advanced
functions via the `$PSCmdlet` variable.

```powershell
using namespace System.Management.Automation;
$Exception = [Exception]::new("error message")
$ErrorRecord = [ErrorRecord]::new(
    $Exception,
    "errorID",
    [ErrorCategory]::NotSpecified,
    $TargetObject # usually the object that triggered the error, if possible
)
$PSCmdlet.ThrowTerminatingError($ErrorRecord)
```

As you can see, these require a little more _manual labor_.
You can bypass some of this by _deliberately_ using the `throw` statement and then later `catch`ing
the generated `ErrorRecord` to pass it into the `ThrowTerminatingError()` method directly, saving a
decent amount of the code involved and offloading the work to PowerShell's engine instead.
However, this will still involve essentially the same work being done, without necessarily giving
you a chance to specify the finer details of the error record.

`ThrowTerminatingError()` creates a terminating error (as the name implies), however _unlike_
`throw` its errors are _unaffected_ by `-ErrorAction` parameters applied to the parent function.
It will also never reveal the code around it; when you see an error thrown via this method, it will
**always** display only the line where the command was called, never the code within the command
that actually threw the error.

`ThrowTerminatingError()` should generally be used for _serious_ errors, where continuing to process
in spite of the error may lead to corrupted data.

## Non-Terminating Errors


Some text.

so throw is terminating, but Write-Error is not. However, both will always point to the line where the error was thrown or written, not where it actually occurred. This is sometimes what you want, not always.

ThrowTerminatingError() does something similar to throw, except its error is not affected by -ErrorAction
also, it always shows the line where your function was called, never a line inside your function, in the error message
WriteError() is similar to the above, but non-terminating and is affected by -ErrorAction
exit I believe terminates the current script or process completely and probably shouldn't ever be used except in interactive use
return exits the current scope and passes control to the caller
(without erroring)
basically if you're throwing from an expected error
(i.e., forseeable user error-sourced error)
I would use $PSCmdlet.WriteError() or the terminating version if it's serious
because that indicates to the user "hey you messed this up"
worth noting that an easy way to build ErrorRecords for use with the PSCmdlet functions here is to throw in your try/catch and then pass the error record to the appropriate WriteError()/ThrowTerminatingError() method
from the catch block
(cause throw creates error records for you)

but if it's a completely unexpected error that is thrown you probably want to use throw directly out of the function
because that gives the user a very useful bug reporting tool for you
so when you catch, know the errors you expect and catch them in a typed catch block
(you can pass multiple types to a single catch block, too)
when you do a generic catch unless you know what you're after just throw it on out again so that you can eventually fix what happened
