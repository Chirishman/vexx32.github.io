---
layout: post
title: Error Handling in PowerShell - Best Practices
date: 2019-01-24
categories: [PowerShell, Scripting, "Best Practices"]
tags: [powershell, pwsh, errors]
---

Intro paragraph (this will be used as the synopsis/summary/excerpt on the post listing pages)

# First Heading

Some text.

so throw is terminating, but Write-Error is not. However, both will always point to the line where the error was thrown or written, not where it actually occurred. This is sometimes what you want, not always.

ThrowTerminatingError() does something similar to throw, except its error is not affected by -ErrorAction
also, it always shows the line where your function was called, never a line inside your function, in the error message
WriteError() is similar to the above, but non-terminating and is affected by -ErrorAction
exit I believe terminates the current script or process completely and probably shouldn't ever be used except in interactive use
return exits the current scope and passes control to the caller
(without erroring)
basically if you're throwing from an expected error
(i.e., forseeable user error-sourced error)
I would use $PSCmdlet.WriteError() or the terminating version if it's serious
because that indicates to the user "hey you messed this up"
worth noting that an easy way to build ErrorRecords for use with the PSCmdlet functions here is to throw in your try/catch and then pass the error record to the appropriate WriteError()/ThrowTerminatingError() method
from the catch block
(cause throw creates error records for you)

but if it's a completely unexpected error that is thrown you probably want to use throw directly out of the function
because that gives the user a very useful bug reporting tool for you
so when you catch, know the errors you expect and catch them in a typed catch block
(you can pass multiple types to a single catch block, too)
when you do a generic catch unless you know what you're after just throw it on out again so that you can eventually fix what happened
